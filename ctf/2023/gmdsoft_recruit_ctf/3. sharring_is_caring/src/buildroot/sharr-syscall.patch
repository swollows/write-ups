diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 9d3cbe7..b611339 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1677,7 +1677,8 @@ config ARM64_BTI_KERNEL
 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94697
 	depends on !CC_IS_GCC || GCC_VERSION >= 100100
 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106671
-	depends on !CC_IS_GCC
+	# Force enable BTI regardless of compiler bugs
+	# depends on !CC_IS_GCC
 	# https://github.com/llvm/llvm-project/commit/a88c722e687e6780dcd6a58718350dc76fcc4cc9
 	depends on !CC_IS_CLANG || CLANG_VERSION >= 120000
 	depends on (!FUNCTION_GRAPH_TRACER || DYNAMIC_FTRACE_WITH_REGS)
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index 3b269c7..dc159a5 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -308,11 +308,8 @@ void __init arm64_memblock_init(void)
 
 	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {
 		extern u16 memstart_offset_seed;
-		u64 mmfr0 = read_cpuid(ID_AA64MMFR0_EL1);
-		int parange = cpuid_feature_extract_unsigned_field(
-					mmfr0, ID_AA64MMFR0_PARANGE_SHIFT);
 		s64 range = linear_region_size -
-			    BIT(id_aa64mmfr0_parange_to_phys_shift(parange));
+			    (memblock_end_of_DRAM() - memblock_start_of_DRAM());
 
 		/*
 		 * If the size of the linear region exceeds, by a sufficient
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 252243c..f998a57 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -897,6 +897,10 @@ asmlinkage long sys_execve(const char __user *filename,
 		const char __user *const __user *argv,
 		const char __user *const __user *envp);
 
+/* mm/sharr.c */
+asmlinkage long sys_sharr_readv(const size_t __user *iv, size_t __user *data, size_t len);
+asmlinkage long sys_sharr_writev(const size_t __user *iv, const size_t __user *data, size_t len);
+
 /* mm/fadvise.c */
 asmlinkage long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);
 
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 1c5fb86..a6abdba 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -880,8 +880,13 @@ __SYSCALL(__NR_memfd_secret, sys_memfd_secret)
 #define __NR_process_mrelease 448
 __SYSCALL(__NR_process_mrelease, sys_process_mrelease)
 
+#define __NR_sharr_readv 449
+__SYSCALL(__NR_sharr_readv, sys_sharr_readv)
+#define __NR_sharr_writev 450
+__SYSCALL(__NR_sharr_writev, sys_sharr_writev)
+
 #undef __NR_syscalls
-#define __NR_syscalls 449
+#define __NR_syscalls 451
 
 /*
  * 32 bit systems traditionally used different
diff --git a/mm/Makefile b/mm/Makefile
index fc60a40..e0655af 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -65,6 +65,7 @@ obj-y += page-alloc.o
 obj-y += init-mm.o
 obj-y += memblock.o
 obj-y += $(memory-hotplug-y)
+obj-y += sharr.o
 
 ifdef CONFIG_MMU
 	obj-$(CONFIG_ADVISE_SYSCALLS)	+= madvise.o
diff --git a/mm/sharr.c b/mm/sharr.c
new file mode 100644
index 0000000..55fdacb
--- /dev/null
+++ b/mm/sharr.c
@@ -0,0 +1,73 @@
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+
+#define SHARR_LENGTH 0x1000
+
+size_t sharr[SHARR_LENGTH];
+EXPORT_SYMBOL(sharr);
+
+static int arg_check(const size_t __user *iv, const size_t __user *data, size_t len)
+{
+	long i;
+
+	// verify length
+	if (len > SHARR_LENGTH)
+		return -EINVAL;
+
+	// verify iv & data address
+	if (!access_ok(iv, len * sizeof(size_t)) || !access_ok(data, len * sizeof(size_t)))
+		return -EFAULT;
+
+	// verify iv indices
+	for (i = 0; i < len; i++) {
+		size_t idx;
+		if (copy_from_user(&idx, iv + i, sizeof(size_t)))
+			return -EFAULT;
+		if (idx >= SHARR_LENGTH)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+SYSCALL_DEFINE3(sharr_readv, const size_t __user *, iv, size_t __user *, data, size_t, len)
+{
+	long ret, i;
+
+	ret = arg_check(iv, data, len);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < len; i++) {
+		size_t idx, value;
+		if (copy_from_user(&idx, iv + i, sizeof(size_t)))
+			continue;
+		value = sharr[idx];
+		if (copy_to_user(data + i, &value, sizeof(size_t)))
+			continue;
+		ret++;
+	}
+
+	return ret;
+}
+
+SYSCALL_DEFINE3(sharr_writev, const size_t __user *, iv, const size_t __user *, data, size_t, len)
+{
+	long ret, i;
+
+	ret = arg_check(iv, data, len);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < len; i++) {
+		size_t idx, value;
+		if (copy_from_user(&idx, iv + i, sizeof(size_t)))
+			continue;
+		if (copy_from_user(&value, data + i, sizeof(size_t)))
+			continue;
+		sharr[idx] = value;
+		ret++;
+	}
+
+	return ret;
+}
