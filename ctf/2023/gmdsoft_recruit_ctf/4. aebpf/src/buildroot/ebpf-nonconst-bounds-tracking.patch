diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 9d3cbe7..b611339 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1677,7 +1677,8 @@ config ARM64_BTI_KERNEL
 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94697
 	depends on !CC_IS_GCC || GCC_VERSION >= 100100
 	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106671
-	depends on !CC_IS_GCC
+	# Force enable BTI regardless of compiler bugs
+	# depends on !CC_IS_GCC
 	# https://github.com/llvm/llvm-project/commit/a88c722e687e6780dcd6a58718350dc76fcc4cc9
 	depends on !CC_IS_CLANG || CLANG_VERSION >= 120000
 	depends on (!FUNCTION_GRAPH_TRACER || DYNAMIC_FTRACE_WITH_REGS)
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index 3b269c7..dc159a5 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -308,11 +308,8 @@ void __init arm64_memblock_init(void)
 
 	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {
 		extern u16 memstart_offset_seed;
-		u64 mmfr0 = read_cpuid(ID_AA64MMFR0_EL1);
-		int parange = cpuid_feature_extract_unsigned_field(
-					mmfr0, ID_AA64MMFR0_PARANGE_SHIFT);
 		s64 range = linear_region_size -
-			    BIT(id_aa64mmfr0_parange_to_phys_shift(parange));
+			    (memblock_end_of_DRAM() - memblock_start_of_DRAM());
 
 		/*
 		 * If the size of the linear region exceeds, by a sufficient
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 1c95d97..dd62e4f 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -2706,16 +2706,21 @@ static int check_stack_write_fixed_off(struct bpf_verifier_env *env,
 		save_register_state(state, spi, reg, size);
 	} else if (reg && is_spillable_regtype(reg->type)) {
 		/* register containing pointer is being spilled into stack */
-		if (size != BPF_REG_SIZE) {
-			verbose_linfo(env, insn_idx, "; ");
-			verbose(env, "invalid size of register spill\n");
-			return -EACCES;
-		}
-		if (state != cur && reg->type == PTR_TO_STACK) {
-			verbose(env, "cannot spill pointers to stack into stack frame of the caller\n");
-			return -EINVAL;
+		if (env->allow_ptr_leaks) {
+			if (size != BPF_REG_SIZE) {
+				verbose_linfo(env, insn_idx, "; ");
+				verbose(env, "invalid size of register spill\n");
+				return -EACCES;
+			}
+			if (state != cur && reg->type == PTR_TO_STACK) {
+				verbose(env, "cannot spill pointers to stack into stack frame of the caller\n");
+				return -EINVAL;
+			}
+			save_register_state(state, spi, reg, size);
+		} else {
+			verbose(env, "pointer spill to stack is allowed only to CAP_PERFMON and CAP_SYS_ADMIN\n");
+			return -EPERM;
 		}
-		save_register_state(state, spi, reg, size);
 	} else {
 		u8 type = STACK_MISC;
 
@@ -7893,12 +7898,6 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 		}
 	}
 
-	if (!src_known &&
-	    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {
-		__mark_reg_unknown(env, dst_reg);
-		return 0;
-	}
-
 	if (sanitize_needed(opcode)) {
 		ret = sanitize_val_alu(env, insn);
 		if (ret < 0)
